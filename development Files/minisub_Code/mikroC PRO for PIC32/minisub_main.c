/*
* Project name:
    Mini-Sub Game Demo V3
* Generated by:
    Visual TFT
* V3 Released
    9/30/2012
* V2.2 Released
    11/25/2011
* V2.1 Released
    10/04/2011
* V2 Released
    9/30/2011
* V1 Released
    9/14/2011

* Created By:
    Andrew Hazelden
* Email:
    andrewhazelden@gmail.com
* Blog:
    http://www.andrewhazelden.com

* Test configuration:
    MCU:              P32MX460F512L
    
    Dev. Board:       Mikromedia WorkStation v7
                      http://www.mikroe.com/eng/products/view/881/mikromedia-workstation/
                      
                      MikroMMB_for_PIC32_hw_rev_1.10
                      http://www.mikroe.com/eng/products/view/595/mikrommb-for-pic32-board/
                      
    Optional Accessory Board:
                      Mikromedia Gaming Shield 1.00
                      http://www.mikroe.com/mikromedia/shields/gaming/
                      
    Oscillator:      80000000 Hz
    SW:              mikroC PRO for PIC32
                      http://www.mikroe.com/eng/products/view/623/mikroc-pro-for-pic32/
                      

To compile the Mini-Sub game the Mikromedia Workstation v7 Board support package is required from libstock.com
http://www.libstock.com/projects/view/368/mikromedia-workstation-v7-bsp
                      
                      
When you compile the program you can choose between either enabling Mikromedia Workstation v7 Joystick support or
support for the Mikromedia Gaming Shield input board by uncommenting the first #define.

If the line "#define ENABLE_MIKROMEIDA_WORKSTATION_JOYSTICK_SUPPORT" is enabled then the code
to enable Mikromedia Workstation support is turned on.

If you comment out the line  "#define ENABLE_MIKROMEIDA_WORKSTATION_JOYSTICK_SUPPORT" then the
code to enable the Mikromedia Gaming Shield is turned on.

*/


//Uncomment the next line to enable Mikromedia Workstation v7 Joystick support
//#define ENABLE_MIKROMEIDA_WORKSTATION_JOYSTICK_SUPPORT
// --------------------------------------------------------
// --------------------------------------------------------


#include "minisub_objects.h"
#include "minisub_resources.h"
#include "minisub_setup.h"

// --------------------------------------------------------
// --------------------------------------------------------

#ifndef ENABLE_MIKROMEIDA_WORKSTATION_JOYSTICK_SUPPORT
  //This adds the Mikromedia Gaming Shield library
  #include "gaming-shield.h"
  //From "gaming-shield.h" - Sets up the Gaming Shield
  extern void InitGameShield();
#endif

//Mini-Sub player dimensions
#define PLAYER_HEIGHT 47
#define PLAYER_WIDTH 63

//Status bar height
#define STATUS_TEXT_CELL_HEIGHT 25


//Add fallback support for mini-sub if the gaming shield isn't used
#ifdef ENABLE_MIKROMEIDA_WORKSTATION_JOYSTICK_SUPPORT
  int upButton=0;
  int downButton=0;
  int rightButton=0;
  int leftButton=0;
  int startButton=0;
  int LED1=0;
#endif


int torpedoButton=0;

int muteButton=0;



void Start_WS();
void UART1_Write_Line(char *uart_text);
void UART1_Write_Variable(int var);
void UART1_Write_Long_Variable(long var);

void UART1_Write_Label_Var(char *uart_text, int var );
void UART1_Write_Label_Long_Var(char *uart_text, long var);
void UART1_Write_Label_Float_Var(char *uart_text, float var);


extern void RefreshMenu();



//define the startup sound volume
void Startup_Volume( char vol);

extern char sound_level, old_sound_level;
extern void MP3_Set_Volume(char left, char right);
void UpdateVolumeBar(char vol, char old_vol);

//Count how many songs have played
extern int song_count;

//Flag to indicate that the current song is done playing
extern int play_next_song;

//Mute sound flag
int muteSound = 0;
int prev_muteSound = 0;

//Bonus frequency factor
int bonus_factor = 1;

int show_main_menu = 0;
int toggled_main_menu = 0;

void main() {

  Start_TP();
  
  //Start with a black screen
  TFT_Fill_Screen(CL_BLACK);
  
  Start_WS();
  
  #ifndef ENABLE_MIKROMEIDA_WORKSTATION_JOYSTICK_SUPPORT
    InitGameShield();
  #endif
  
  //setup the default font
  TFT_Set_Font(TFT_defaultFont, CL_WHITE, FO_HORIZONTAL);
  
  //Set up VLSI VS1011E chip sound playback
  file_loaded = 0;
  MP3_Start();

  Startup_Volume(80);  //Set the startup volume to 50%
  
  //Fill the screen with the blue sea color
  TFT_Fill_Screen(bgColor);
  
  UART1_Write_Line("Mini-Sub Game Started");

  while (1) {
    
    //Reset the game
    ResetGame();
    
    //Show the animated game intro title
    ShowTitles();
    
    //Show the help screen for the game
    //ShowHelp();

    show_main_menu=1;
    start_game_flag=1;

    RefreshMenu();
    //Show the game's Main Menu display
    while(show_main_menu==1)
    {
      if(toggled_main_menu){
        RefreshMenu();
        toggled_main_menu=0;
      }

      Check_TP();
      
      UART1_Write_Line(".");
      Play_MP3_Chunk();
      
    }

    //Run the game until the player is out of lives
    while(subLives){
      
      //Reset the sprites
      InitSprites();
      
      //Run the current level until the sub hits a mine
      while (mineHit == 0) {

        //Play the background music
        if(play_next_song){
          //Switch the current song if it is done playing
          GetNextSong();
        }
        else if( (frame_counter % 2) == 0){
          //Play a chunk of the current song every 2nd frame
          Play_MP3_Chunk();
        }

        //Show the game's Main Menu display
        if(show_main_menu==1)
        {
          if(toggled_main_menu){
            RefreshMenu();
            toggled_main_menu=0;
          }
          
          Check_TP();
        }
        else
        {
          
          if(toggled_main_menu){
            //Set the line drawing color
            TFT_Set_Pen(bgColor, 1);

            //Set the shape fill color
            TFT_Set_Brush(1, bgColor, 0, TOP_TO_BOTTOM, CL_BLACK, CL_BLACK);

            //Fill the screen with the blue sea color
            TFT_Fill_Screen(bgColor);
            
            toggled_main_menu=0;
          }
          
          //Check for user input
          GetInput();
          
          //Draw the graphics
          RenderScreen();

          //Store the previous values
          SavePreviousVal();
          
          //Increment the frame counter
          frame_counter++;
        }
        

        
      } //End of the current sub life

      //Reset the mine hit counter
      mineHit = 0;
      
      //Reset the mineExplode counter
      mineExplode = 0;

      //Reduce the life counter because a submarine blew up
      subLives--;
    }

    //Display the game over title screen
    ShowGameOver();
  }

}


//Prepare the Mikromedia Workstation & setup the UART
void Start_WS(){

  WS_Init();                      //Setup the Mikromedia Workstation

  WS_UART_Init(256000);
  Delay_ms(100);                  // Wait for UART module to stabilize
}

//UART1 write text and new line (carriage return + line feed)
void UART1_Write_Line(char *uart_text) {
  UART1_Write_Text(uart_text);
  UART1_Write(13);
  UART1_Write(10);
}

//UART1 write integer variable and new line (carriage return + line feed)
void UART1_Write_Variable(int var) {
  char var_txt[12];
  IntToStr(var, var_txt);
  UART1_Write_Text(var_txt);
  UART1_Write(13);
  UART1_Write(10);
}

//UART1 write long variable and new line (carriage return + line feed)
void UART1_Write_Long_Variable(long var){
  char var_txt[20];
  LongWordToStr(var, var_txt);
  UART1_Write_Text(var_txt);
  UART1_Write(13);
  UART1_Write(10);
}


//Display the Mini-Sub title
void ShowTitles(){
  int step_value = 15;

  //Fill the screen with the blue sea color
  TFT_Fill_Screen(bgColor);

  //setup the default font
  TFT_Set_Font(TFT_defaultFont, CL_WHITE, FO_HORIZONTAL);

  TFT_Set_Pen(bgColor, 1);
  
  //Set the fill brush to the sea color
  TFT_Set_Brush(1, bgColor, 0, TOP_TO_BOTTOM, bgColor, bgColor);

  //Display the Mini-Sub title image
  TFT_Image(35, (SCREEN_HEIGHT/2)-47, title_bmp, 1);


  //Write press start to play the game
  //TFT_Write_Text("Press the Start button to play.", 75, 220);
  //TFT_Write_Text("Tap the screen to start the game.", 65, 220);
  TFT_Write_Text("Loading the game...", 100, 220);
  
  //Set up the submarine y height
  sub.y = 160;
  
  //Draw the mini-sub image
  sub.x = step_value+1;
  TFT_Image(sub.x, sub.y, sub_bmp, 1);

  //Start loading the bg music
  GetNextSong();
  
  //Animate the sub across the screen
  for(sub.x = step_value+1;(sub.x <= (SCREEN_WIDTH+1)) && (!startButton);sub.x+=step_value){

    //Draw the mini-sub image
    TFT_Image(sub.x, sub.y, sub_bmp, 1);
    
    //Play background music
    Play_MP3_Chunk();

    //Clear the mini-sub
    TFT_Rectangle(sub.x-step_value, sub.y, sub.x+step_value, sub.y + PLAYER_HEIGHT );
    
    //Increment the frame counter
    frame_counter++;
    
    //Check if you tapped the screen
    if(TP_TFT_Press_Detect()){
      if (TP_TFT_Get_Coordinates(&X_Coord, &Y_Coord) == 0) {
        start_game_flag = 1;
      }
    }
    
    //The user pressed the start button
    if(startButton){
      start_game_flag = 1;
    }
    
    #ifdef ENABLE_MIKROMEIDA_WORKSTATION_JOYSTICK_SUPPORT
    //The user pressed the mikromedia workstation joystick button
    if (WS_Joystick_Push_Pressed()){
      start_game_flag = 1;
    }
    #endif
    
    //The user pressed the circle button (mute)
    if(muteButton){
      //Toggle the sound ON / OFF (Mute)
      ToggleMute();
    }
    
    if(start_game_flag){
      break;
    }
    
  }

  //Fill the screen with the blue sea color
  TFT_Fill_Screen(bgColor);
}



void ShowHelp(){
  int loop = 0;
  UART1_Write_Line("Help Screens");

  //Set the line drawing color
  TFT_Set_Pen(bgColor, 1);

  //Set the shape fill color
  TFT_Set_Brush(1, bgColor, 0, TOP_TO_BOTTOM, CL_BLACK, CL_BLACK);

  //Fill the screen with the blue sea color
  TFT_Fill_Screen(bgColor);


  //setup the default font
  TFT_Set_Font(TFT_defaultFont, CL_WHITE, FO_HORIZONTAL);


  if(!start_game_flag){
    //Screen 1

    TFT_Write_Text("Overview", 132, 8);

    //Draw the mini-sub image
    TFT_Image(8, 46, sub_bmp, 1);   //8, 43

    TFT_Write_Text("Navigate  your  sub  through  an", 86, 48);
    TFT_Write_Text("ocean  filled  with  dangerous  sea", 86, 64);
    TFT_Write_Text("mines  while  collecting  points.", 86, 80);


    TFT_Write_Text("Pickup  bonus  items  as  you  go:", 17, 115); //96

    //Draw torpedo bonus pack
    TFT_Image(18, 137, torpedo_pack_bmp, 1);
    TFT_Write_Text("Pickup  3  extra  torpedoes.", 86, 151);    //130

    //Draw heart bonus pack
    TFT_Image(17, 188, heart_pack_bmp, 1);
    TFT_Write_Text("Pickup  an  extra  life.", 86, 202);  //194

    //Keep the sound playing
    for(loop = 0; (loop<=80) && (!start_game_flag);loop++){
      Play_MP3_Chunk();
      Delay_ms(50);

      //Check if you tapped the screen
      if(TP_TFT_Press_Detect()){
        if (TP_TFT_Get_Coordinates(&X_Coord, &Y_Coord) == 0) {
          start_game_flag = 1;
        }
      }


      //The user pressed the start button
      if(startButton){
        start_game_flag = 1;
      }

      
      #ifdef ENABLE_MIKROMEIDA_WORKSTATION_JOYSTICK_SUPPORT
      //The user pressed the mikromedia workstation joystick button
      if (WS_Joystick_Push_Pressed()){
        start_game_flag = 1;
      }
      #endif

      
      //The user pressed the circle button (mute)
      if(muteButton){
        //Toggle the sound ON / OFF (Mute)
        ToggleMute();

        //LED1 = 0;
        Delay_ms(250);
      }
      
    }

  }
  
  if(!start_game_flag){
    //Screen 2

    //Fill the screen with the blue sea color
    TFT_Fill_Screen(bgColor);

    TFT_Write_Text("Overview", 132, 8);
    
    #ifdef ENABLE_MIKROMEIDA_WORKSTATION_JOYSTICK_SUPPORT
      TFT_Write_Text("Use  the  joystick  to  move  the  sub.", 50, 24);
    #else
      TFT_Write_Text("Use  the arrow keys to  move  the  sub.", 50, 24);
    #endif

    
    //Draw the mini-sub image
    TFT_Image(24, 116, sub_bmp, 1);

    //Draw the torpedo
    TFT_Image(102, 132, torpedo_bmp, 1);

    //Draw some red sea mines
    TFT_Image(187, 117, mine1_bmp, 1);
    TFT_Image(248, 56, mine2_bmp, 1);
    //Draw a grey sea mine
    TFT_Image(118, 54, dark_mine1_bmp, 1);

    #ifdef ENABLE_MIKROMEIDA_WORKSTATION_JOYSTICK_SUPPORT
      TFT_Write_Text("Click  the  joystick  to  fire  your  torpedoes.", 25, 184);//191
    #else
      TFT_Write_Text("Press  the  square  button  to  fire your torpedoes.", 5, 175);//191
    #endif
    
    TFT_Write_Text("Red  sea  mines  take  1  torpedo  hit.", 40, 200);
    TFT_Write_Text("Grey  sea  mines  take  2  torpedo  hits.", 40, 216);
    
    //Keep the sound playing
    for(loop = 0; (loop<=100) && (!start_game_flag);loop++){
      Play_MP3_Chunk();
      Delay_ms(50);

      //Check if you tapped the screen
      if(TP_TFT_Press_Detect()){
        if (TP_TFT_Get_Coordinates(&X_Coord, &Y_Coord) == 0) {
          start_game_flag = 1;
        }
      }

      //The user pressed the start button
      if(startButton){
        start_game_flag = 1;
      }
      
      #ifdef ENABLE_MIKROMEIDA_WORKSTATION_JOYSTICK_SUPPORT
      //The user pressed the mikromedia workstation joystick button
      if (WS_Joystick_Push_Pressed()){
        start_game_flag = 1;
      }   
      #endif

      
      //The user pressed the circle button (mute)
      if(muteButton){
        //Toggle the sound ON / OFF (Mute)
        ToggleMute();

        //LED1 = 0;
        //Delay_ms(50);
      }

    }

  }


  if(!start_game_flag){
    //Screen 3

    //Fill the screen with the blue sea color
    TFT_Fill_Screen(bgColor);


    //Show the score bar
    RenderScore();

    TFT_Write_Text("Icons  Explained", 122, 50);
    
    TFT_Write_Text("This  icon  shows  how  many  lives  remain.", 50, 80);
    TFT_Image(20, 80, lives_bmp, 1);

    TFT_Write_Text("This  icon   shows  your  torpedo  count.", 50, 110);
    TFT_Image(22, 110, torpedo_status_bmp, 1);
    TFT_Image(28, 110, torpedo_status_bmp, 1);
    TFT_Image(34, 110, torpedo_status_bmp, 1);
    
    TFT_Write_Text("This  icon  shows  the  sound  volume.", 50, 145);
    TFT_Image(20, 145, sound_bmp, 1);
    
    TFT_Write_Text("Tip:  While   playing   the   game   tap   the   screen", 25, 200);
    TFT_Write_Text("to   load   the   main   menu.", 60, 216);
    
    //Keep the sound playing
    for(loop = 0; (loop<=80) && (!start_game_flag);loop++){
      Play_MP3_Chunk();
      Delay_ms(50);

      //Check if you tapped the screen
      if(TP_TFT_Press_Detect()){
        if (TP_TFT_Get_Coordinates(&X_Coord, &Y_Coord) == 0) {
          start_game_flag = 1;
        }
      }

      //The user pressed the start button
      if(startButton){
        start_game_flag = 1;
      }
      
      #ifdef ENABLE_MIKROMEIDA_WORKSTATION_JOYSTICK_SUPPORT
      //The user pressed the mikromedia workstation joystick button
      if (WS_Joystick_Push_Pressed()){
        start_game_flag = 1;
      }     
      #endif

      //The user pressed the circle button (mute)
      if(muteButton){
        //Toggle the sound ON / OFF (Mute)
        ToggleMute();

        //LED1 = 0;
        //Delay_ms(50);
      }

    }
    //Fill the screen with the blue sea color
    TFT_Fill_Screen(bgColor);

  }

  if(!start_game_flag){
    //Screen 4

    //Fill the screen with the blue sea color
    TFT_Fill_Screen(bgColor);

    TFT_Write_Text("Credits", 132, 8);

    //Draw the credits 32px x 32px icons
    TFT_Image(28, 36,  andrew_bmp, 1);
    TFT_Image(28, 109, tonyB_bmp, 1);
    TFT_Image(28, 178, mikroe_bmp, 1);
    
    
    //font text row spacing 16 pixels

    TFT_Write_Text("Game   by   Andrew   Hazelden", 82, 44);
    
    TFT_Write_Text("Music   by   Tony   B   Machine", 82, 117);
    
    TFT_Write_Text("Developed   using   MikroElektronika's", 82, 178);
    TFT_Write_Text("MikroC   Pro   for   PIC32   compiler.", 82, 194); //195


    //Keep the sound playing
    for(loop = 0; (loop<=60) && (!start_game_flag);loop++){
      Play_MP3_Chunk();
      Delay_ms(50);


      //Check if you tapped the screen
      if(TP_TFT_Press_Detect()){
        if (TP_TFT_Get_Coordinates(&X_Coord, &Y_Coord) == 0) {
          start_game_flag = 1;
        }
      }
      
      //The user pressed the start button
      if(startButton){
        start_game_flag = 1;
      }
      
      #ifdef ENABLE_MIKROMEIDA_WORKSTATION_JOYSTICK_SUPPORT
      //The user pressed the mikromedia workstation joystick button
      if (WS_Joystick_Push_Pressed()){
        start_game_flag = 1;
      }     
      #endif

      
      
      //The user pressed the circle button (mute)
      if(muteButton){
        //Toggle the sound ON / OFF (Mute)
        ToggleMute();

        //LED1 = 0;
        //Delay_ms(50);
      }

    }
    //Fill the screen with the blue sea color
    TFT_Fill_Screen(bgColor);

  }


}


void ShowNextLevel(){
  int loop = 0;

  //Check if the user is on the next level
  if (prev_level != level){

    //Write out the current level
    UART1_Write_Line("Next Level: ");
    UART1_Write_Variable(level);
    UART1_Write(13);
    UART1_Write(10);

    //Write out the current score
    UART1_Write_Line("Score: ");
    UART1_Write_Variable(score);
    UART1_Write(13);
    UART1_Write(10);

    //Write out the current mine speed
    UART1_Write_Line("Mine Speed: ");
    UART1_Write_Variable(mine_speed);
    UART1_Write(13);
    UART1_Write(10);

    //Write out the current bonus factor
    UART1_Write_Line("Bonus distance factor: ");
    UART1_Write_Variable(bonus_factor);
    UART1_Write(13);
    UART1_Write(10);

    //Fill the screen with the blue sea color
    TFT_Fill_Screen(bgColor);

    //Display the game title
    TFT_Image(35, (SCREEN_HEIGHT/2)-47, title_bmp, 1);
    
    //Set the font color
    TFT_Set_Font(TFT_defaultFont, CL_WHITE, FO_HORIZONTAL);

    //Convert the level from an int to string
    IntToStr(level, level_text);
    strcpy(level_display_text, "Level: ");
    strcat(level_display_text, level_text);

    //Write the next level
    TFT_Write_Text(level_display_text, 140, 150);
    
    //Write "You Earned an Extra Life!"
    TFT_Write_Text("You  Earned  an  Extra  Life!", 80, 180);
    

    //Keep the sound playing
    for(loop = 0; loop<=50;loop++){
      Play_MP3_Chunk();
      Delay_ms(50);
    }


    //Fill the screen with the blue sea color
    TFT_Fill_Screen(bgColor);
    
    //Reset the sprite positions for the next level
    InitSprites();
  }


}







//Display the game over title
void ShowGameOver(){
  int loop = 0;

  UART1_Write_Line("Game Over");
  
  //Fill the screen with the blue sea color
  TFT_Fill_Screen(bgColor);
  
  //Display the game over title
  TFT_Image(0, (SCREEN_HEIGHT/2)-47, GameOver_bmp, 1);
  
  //Set the font color
  TFT_Set_Font(TFT_defaultFont, CL_WHITE, FO_HORIZONTAL);
  
  
  //Check if you set a high score:
  if(score > high_score){
    //You have a high score
    high_score = score;
    TFT_Write_Text("You  set  a  High  Score!", 95, 140);
  }
  else{
    //Show the previous high score
    
    //Convert the high_score from an int to string
    IntToStr(high_score, score_text);
    strcpy(score_display_text, "High  Score: ");
    strcat(score_display_text, score_text);

    //Write the high score
    TFT_Write_Text(score_display_text, 110, 140);
  }
  
  //Convert the score from an int to string
  IntToStr(score, score_text);
  strcpy(score_display_text, "Your  Score: ");
  strcat(score_display_text, score_text);

  //Write the score
  TFT_Write_Text(score_display_text, 110, 170);

  //Keep the sound playing
  for(loop = 0; loop<=60;loop++){
    Play_MP3_Chunk();
    Delay_ms(50);
  }


  //Fill the screen with the blue sea color
  TFT_Fill_Screen(bgColor);
}




void GetInput()  {
  int mine_inc = 0;
  int edge_border = 3;


  //Enable the Mikromedia Game Shield circble button as fire
  #ifndef ENABLE_MIKROMEIDA_WORKSTATION_JOYSTICK_SUPPORT
  //Make the torpedoButton variable the circle button on the Mikromedia gaming shield
  torpedoButton = squareButton;
  #endif
  

  //Enable the Mikromedia Workstation Joystick Input
  #ifdef ENABLE_MIKROMEIDA_WORKSTATION_JOYSTICK_SUPPORT
  if (WS_Joystick_Push_Pressed()){  
    startButton=1;
    torpedoButton=1;
  }
  else
  {
    startButton=0;
    torpedoButton=0;
  }
  
  
  if (WS_Joystick_Up_Pressed()){  
    upButton=1;
  }
  else
  {
    upButton=0;
  }
  
  if (WS_Joystick_Down_Pressed()){  
    downButton=1;
  }
  else
  {
    downButton=0;
  }
  
  if (WS_Joystick_Left_Pressed()){  
    leftButton=1;
  }
  else
  {
    leftButton=0;
  }
  
  
  if (WS_Joystick_Right_Pressed()){  
    rightButton=1;
  }
  else
  {
    rightButton=0;
  }
  
  //End of Mikromedia Workstation Joystick support   
#endif

  
  //Check if you tapped the screen
  if(TP_TFT_Press_Detect()){

    if (TP_TFT_Get_Coordinates(&X_Coord, &Y_Coord) == 0) {

      //Capture the starting press location
      if(Pen_Down == 0){
        Starting_Pen_Down_X_Coord = X_Coord;
        Starting_Pen_Down_Y_Coord = Y_Coord;
        //UART1_Write_Label_Var("Starting pen X:", Starting_Pen_Down_X_Coord);
        //UART1_Write_Label_Var("Starting pen Y:", Starting_Pen_Down_Y_Coord);
      }

      X_Drag_Distance =  Starting_Pen_Down_X_Coord - X_Coord;

      //The pen has been pressed onscreen
      Pen_Down = 1;

    }  //end of tap x / y location checking
    
  }
  else{
    //the pen was released
    Pen_Down = 0;
  }

  //Check if the screen has been pressed
  if( (Pen_Down == 1 )) {
    
    
    toggled_main_menu=1;
    
    if(show_main_menu){
      show_main_menu=0;
    }
    else{
      show_main_menu=1;
    }
    
    //delay until the tap was released
    while(!TP_TFT_Press_Detect()){
      Delay_ms(50);
    }
    
  }

  
  
  //The user pressed the circle button (mute)
  if(muteButton){
    //Toggle the sound ON / OFF (Mute)
    ToggleMute();
    
    //LED1 = 0;
    Delay_ms(250);
  }
  
  
  if(startButton){
    //UART1_Write_Line("Start");
    
    //Display the button pressed status LED
    //LED1 = 0;
  }
  
  if(upButton) {
    sub.y -= SUB_Y_SPEED;
    //UART1_Write_Line("Up");

    //Display the button pressed status LED
    //LED1 = 0;
  }
  else if(downButton){
    sub.y += SUB_Y_SPEED;
    //UART1_Write_Line("Down");

    //Display the button pressed status LED
    //LED1 = 0;
  }
  else if(leftButton) {
    sub.x -= SUB_SPEED;
    //UART1_Write_Line("Left");

    //Display the button pressed status LED
    //LED1 = 0;
  }
  else if(rightButton){
    sub.x += SUB_SPEED;
    //UART1_Write_Line("Right");

    //Display the button pressed status LED
    //LED1 = 0;
  }
  else{
    
    //Only animate the sub back to the resting position every nth frame
    if( (frame_counter % 2) == 0){
      //Slowly animate the submarine back to its' default x axis resting position
      if(sub.x > DEFAULT_SUB_X_POS){
        sub.x -= 1;
      }
    }
    
    //Only animate the sub back to the resting position every nth frame
    if( (frame_counter % 4) == 0){
      //Slowly animate the submarine back to its' default x axis resting position
      if(sub.x < DEFAULT_SUB_X_POS){
        sub.x += 1;
      }
    }
    
  }
  

  //Check that the sub.y position is below the status text area
  if( sub.y <= STATUS_TEXT_CELL_HEIGHT ){
    sub.y = STATUS_TEXT_CELL_HEIGHT;
  }

  //Check that the sub.x position is greater than 0
  if( sub.x <= 0 ){
    sub.x = 0;
  }

  //Check that the sub.y position is is still onscreen
  if( sub.y >= (SCREEN_HEIGHT-PLAYER_HEIGHT)){
    sub.y = SCREEN_HEIGHT-PLAYER_HEIGHT;
  }

  //Check that the sub.x position is still onscreen
  if( sub.x >= (SCREEN_WIDTH-PLAYER_WIDTH)){
    sub.x = SCREEN_WIDTH-PLAYER_WIDTH;
  }

  //Scan the sea mine array
  for(mine_inc = 0; mine_inc <= (NUMBER_OF_SEA_MINES-1); mine_inc++){

    //Check if the mine.x value is less 0 the sea mine has gone offscreen
    if( mine[mine_inc].x <= edge_border){

      //Draw the new mine position staring on the right edge of the screen
      ResetSeaMine(mine_inc);

      //Redraw the screen
      TFT_Rectangle( mine[mine_inc].prev_x-1, mine[mine_inc].prev_y-1, mine[mine_inc].prev_x + mine[mine_inc].width + 1, mine[mine_inc].prev_y + mine[mine_inc].height + 1);

      //Increase the score after the mine goes off screen
      score += 25;
    }
    else{
      //Animate the sea mine to the left
      mine[mine_inc].x -= mine_speed;
    }

  }
  
  //Check if the bonus block x position is still onscreen
  if(bonus_block.x<=edge_border){
    
    //Redraw the screen
    TFT_Rectangle( bonus_block.prev_x-1, bonus_block.prev_y-1, bonus_block.prev_x + bonus_block.width + 1, bonus_block.prev_y + bonus_block.height + 1);

    //reset the bonus block position
    ResetBonusBlock();
  }
  
  
  //animate the bonus block across the screen
  bonus_block.x -= mine_speed;



  if(torpedoButton){

    //UART1_Write_Line("Fire");

    //Display the button pressed status LED
    //LED1 = 0;

    if(torpedo_count>=1) {
      //Check for first fired button state and reset the torpedo position
      if( fire_torpedo_flag == 0 ) {
        //The torpedo inherits the starting position of the sub
        torpedo.x = sub.x + PLAYER_WIDTH + 1;

        //Set torpedo to launch from the center of the sub
        torpedo.y = sub.y + (PLAYER_HEIGHT/2);

        //The torpedoe visible
        torpedo.visible = 1;

        //Set the flag that the torpedo has been launched
        fire_torpedo_flag = 1;

        //Reduce the torpedo count by 1
        torpedo_count--;
        
      }
    }

  }


  //Check if there are any torpedoes remaining
  if( fire_torpedo_flag == 1 ){
    torpedo.x += TORPEDO_SPEED;

    //Check if the torpedo went off the screen
    if( torpedo.x > (SCREEN_WIDTH+TORPEDO_SPEED+1) ){
      //Hide the torpedo
      torpedo.visible = 0;
      //Reset fire_torpedo flag
      fire_torpedo_flag = 0;
    }

  }



} //end of MoveSub

//Generate a random Y height value
int RandomHeightY(){
  return (rand() % 6) * ((SCREEN_HEIGHT-STATUS_TEXT_CELL_HEIGHT)/6) + STATUS_TEXT_CELL_HEIGHT;
}

int RandomSeaMineType(){
  int mine_type = 0;

  //The grey_mine_rate goes from 1 to 5 of a grey sea mine occuring

  //calculate the random chance of a grey sea mine happening
  mine_type = rand() % grey_mine_rate;

  //Set the percent of the seamines to be grey mines
  if(mine_type == 0){
    return 1;
  }
  else{
    //The rest of the mines are standard red mines
    return 0;
  }
  
  return 0;
}

void ResetBonusBlock(){
  //Reset the position of the bonus block

  //Push the bonus block 4 screens to the right
  bonus_block.x = SCREEN_WIDTH*(BONUS_SCREEN_SPACING*bonus_factor);
  
  //Randomize the block height
  bonus_block.y = RandomHeightY();
  
  //Add 1 to the bonus displayed counter
  bonus_counter += 1;
  
  //If the bonus is rare then make it an extra life
  
  //This random function gives a one in 3 chance for an extra life
  if( (rand() % 3) == 0){
    //Set the bonus to be a heart
    bonus_type = 2;
  }
  else {
    //Set the bonus to be a torpedo pack
    bonus_type = 1;
  }
}

void ResetSeaMine(int mineNumber){
  //Draw the new mine position staring on the right edge of the screen
  //Offset the mine Y position below the text area
  mine[mineNumber].x += SCREEN_WIDTH;
  mine[mineNumber].y = RandomHeightY();
  
  //Picks the seamine type - either red or grey
  mine[mineNumber].type = RandomSeaMineType();
  
  //Reset the mine torpedo hit counter
  mine[mineNumber].hits = 0;
}


//Draw the graphics onscreen
void RenderScreen(){
  int mine_inc = 0;

  //Adds a border to expand the sub redraw zone
  int redraw_border = 3;

  //Calculate the clear mine rects
  for(mine_inc = 0; mine_inc <= (NUMBER_OF_SEA_MINES-1); mine_inc++){

    clear_mine[mine_inc].top =  mine[mine_inc].prev_y;
    if(clear_mine[mine_inc].top < 0)
    clear_mine[mine_inc].top = 0;

    clear_mine[mine_inc].left =  mine[mine_inc].x + mine[mine_inc].width;
    if(clear_mine[mine_inc].left < 0)
    clear_mine[mine_inc].left = 0;

    clear_mine[mine_inc].right = mine[mine_inc].prev_x + mine[mine_inc].width;
    if(clear_mine[mine_inc].right < 0)
    clear_mine[mine_inc].right = 0;

    clear_mine[mine_inc].bottom = mine[mine_inc].prev_y + mine[mine_inc].height;
    if(clear_mine[mine_inc].bottom < 0)
    clear_mine[mine_inc].bottom = 0;

  }

  //The sub has moved to the right
  if(sub.x > sub.prev_x){
    clear_sub.left = sub.prev_x;
    clear_sub.right =  sub.x;
    clear_sub.top = sub.y;
    clear_sub.bottom = sub.y + PLAYER_HEIGHT;
  }
  
  //The sub has moved to the left
  if(sub.x < sub.prev_x){
    clear_sub.left = sub.x+PLAYER_WIDTH;
    clear_sub.right = sub.prev_x+PLAYER_WIDTH;
    clear_sub.top = sub.y;
    clear_sub.bottom = sub.y + PLAYER_HEIGHT;
  }
  
  
  //The sub has moved down
  if(sub.y > sub.prev_y){
    clear_sub.left =  sub.x;
    clear_sub.right =  sub.x+PLAYER_WIDTH;
    clear_sub.top = sub.prev_y;
    clear_sub.bottom =  sub.y;
  }

  //The sub has moved up
  if(sub.y < sub.prev_y){
    clear_sub.left =  sub.x;
    clear_sub.right =  sub.x+PLAYER_WIDTH;
    clear_sub.top = sub.y + PLAYER_HEIGHT;
    clear_sub.bottom = sub.prev_y + PLAYER_HEIGHT;
  }


  //Make sure the top left of the sub clear rect is positive
  if (clear_sub.left <=0)
  clear_sub.left = 0;

  //Keep sub clear rect below status text
  if (clear_sub.top <= STATUS_TEXT_CELL_HEIGHT)
  clear_sub.top = STATUS_TEXT_CELL_HEIGHT;

  //Set up the clear rect for the torpedo
  clear_torpedo.left = torpedo.prev_x-1;
  clear_torpedo.top =  torpedo.prev_y-1;
  clear_torpedo.right =  torpedo.x;
  clear_torpedo.bottom =  torpedo.y+torpedo.height+1;


  //Make sure the top left of the torpedo clear rect is positive
  if (clear_torpedo.left <=0)
  clear_torpedo.left = 0;

  if (clear_torpedo.top <=0)
  clear_torpedo.top = 0;


  //Set up the bonus block clear rect
  clear_bonus_block.top =  bonus_block.prev_y;
  if(clear_bonus_block.top < 0)
  clear_bonus_block.top = 0;

  clear_bonus_block.left =  bonus_block.x + bonus_block.width;
  if(clear_bonus_block.left < 0)
  clear_bonus_block.left = 0;

  clear_bonus_block.right = bonus_block.prev_x + bonus_block.width;
  if(clear_bonus_block.right < 0)
  clear_bonus_block.right = 0;

  clear_bonus_block.bottom = bonus_block.prev_y + bonus_block.height;
  if(clear_bonus_block.bottom < 0)
  clear_bonus_block.bottom = 0;


  //Set the fill brush to the sea color
  TFT_Set_Brush(1, bgColor, 0, TOP_TO_BOTTOM, CL_BLACK, CL_BLACK);

  //Only clear the sub rect if the sub has moved
  if( (sub.prev_x != sub.x)|| (sub.prev_y != sub.y) || (sub.x < (0)) || (sub.y < (STATUS_TEXT_CELL_HEIGHT)) ){
    //clear the rectangle of the old mini-sub sprite
    TFT_Rectangle(clear_sub.left, clear_sub.top, clear_sub.right, clear_sub.bottom);
  }

  //Clear the rectangle of the old sea mine sprites
  for(mine_inc = 0; mine_inc <= (NUMBER_OF_SEA_MINES-1); mine_inc++){
    TFT_Rectangle( clear_mine[mine_inc].left, clear_mine[mine_inc].top, clear_mine[mine_inc].right, clear_mine[mine_inc].bottom);
  }

  //Clear the bonus block rect if the bonus block x position is onscreen
  if(bonus_block.x <= SCREEN_WIDTH){
    //Redraw the screen
    TFT_Rectangle( clear_bonus_block.left, clear_bonus_block.top, clear_bonus_block.right, clear_bonus_block.bottom);
  }


  //Clear the rectangle of the old torpedo
  if(fire_torpedo_flag){
    //Set brush to temporarily view the clear region of the torpedo
    //TFT_Set_Brush(1, CL_BLACK, 0, TOP_TO_BOTTOM, CL_BLACK, CL_BLACK);

    TFT_Rectangle( clear_torpedo.left, clear_torpedo.top, clear_torpedo.right, clear_torpedo.bottom);
  }

  //Set the fill brush to the sea color
  TFT_Set_Brush(1, bgColor, 0, TOP_TO_BOTTOM, CL_BLACK, CL_BLACK);


  //
  //Draw the sprites onscreen
  //


  //Draw the sea mine images
  for(mine_inc = 0; mine_inc <= (NUMBER_OF_SEA_MINES-1); mine_inc++){
    //Animate the seamines
    AnimateSeaMine(mine_inc);
  }

  //Draw the bonus block if the bonus block x position is onscreen
  if(bonus_block.x <= SCREEN_WIDTH){
    //Decide which bonus to display
    
    if(bonus_type == 2) {
      //Set the bonus to be an extra life
      TFT_Image(bonus_block.x, bonus_block.y, heart_pack_bmp, 1);
    }
    else{
      //Set the bonus to be a torpedo pack
      TFT_Image(bonus_block.x, bonus_block.y, torpedo_pack_bmp, 1);
    }
  }

  //Draw the torpedo if it has been fired
  if(fire_torpedo_flag){
    TFT_Image(torpedo.x, torpedo.y, torpedo_bmp, 1);
  }


  //Draw the mini-sub image
  TFT_Image(sub.x, sub.y, sub_bmp, 1);
  
  
  //Debug draw the test black color to view the sub clear rect
  //TFT_Set_Brush(1, CL_BLACK, 0, TOP_TO_BOTTOM, CL_BLACK, CL_BLACK);

  //Only clear the sub rect if the sub has moved
  if( (sub.prev_x != sub.x)|| (sub.prev_y != sub.y) || (sub.x < (0)) || (sub.y < (STATUS_TEXT_CELL_HEIGHT)) ){
    //clear the rectangle of the old mini-sub sprite
    TFT_Rectangle(clear_sub.left, clear_sub.top, clear_sub.right, clear_sub.bottom);
  }


  //Scan the sea mines array to check for a mine hit by the sub
  for(mine_inc = 0; mine_inc <= (NUMBER_OF_SEA_MINES-1); mine_inc++){
    //Check for a mini-sub to sea mine collision
    if(IsCollision(sub.x, sub.y, PLAYER_WIDTH, PLAYER_HEIGHT, mine[mine_inc].x, mine[mine_inc].y, mine[mine_inc].width, mine[mine_inc].height)) {
      //Set a sea mine hit flag
      mineHit = 1;
      
      //Set the id number for the destroyed sea mine
      destroyed_mine_id = mine_inc;

      //debug which mine blew up
      UART1_Write_Line("You hit a sea mine!");
      //UART1_Write_Line("Mine hit:");
      //UART1_Write_Variable(mine_inc);
    }

    if(fire_torpedo_flag){
      //Check for a torpedo to sea mine collision
      if(IsCollision(torpedo.x, torpedo.y, torpedo.width, torpedo.height, mine[mine_inc].x, mine[mine_inc].y, mine[mine_inc].width, mine[mine_inc].height)) {
        
        //Increment the mine hit counter
        mine[mine_inc].hits++;
        
        //Destroy a red sea mine on the first hit
        if(mine[mine_inc].type == 0){
          //Set a sea mine hit flag
          mineExplode = 1;
          
          //Set the id number for the destroyed sea mine
          destroyed_mine_id = mine_inc;

          //Debug which mine blew up
          UART1_Write_Line("Your torpedo destroyed a red sea mine!");
        }
        else if( (mine[mine_inc].type == 1) && (mine[mine_inc].hits >= 2) ){
          //Destroy a grey sea mine if it has been hit twice
          mineExplode = 1;
          
          //Set the id number for the destroyed sea mine
          destroyed_mine_id = mine_inc;

          //Debug which mine blew up
          UART1_Write_Line("Your torpedo destroyed a grey sea mine!");
        }
        else{
          //A grey sea mine was hit a single time
          
          //Reset torpedo launch flag
          fire_torpedo_flag = 0;
          
          //Clear the torpedo sprite
          ClearTorpedo();

          //Reset the torpdedo after the hit
          torpedo.x = 0;
          torpedo.y = 0;
          torpedo.prev_x = 0;
          torpedo.prev_y = 0;
          
        }
        

      }
    }



  }


  //Check for a mini-sub to bonus block collision
  if(IsCollision(sub.x, sub.y, PLAYER_WIDTH, PLAYER_HEIGHT, bonus_block.x, bonus_block.y, bonus_block.width, bonus_block.height)) {

    //Set the id number for the bonus
    bonus_id = 1;
    
    
    if(bonus_type == 2){
      //The sub just picked up an extra life bonus
      subLives += 1;
      
      //debug which bonus was picked up
      UART1_Write_Line("You picked up an extra life bonus!");
    }
    else{
      //The sub just picked up 3 more torpedos
      torpedo_count += 3;
      
      //debug which bonus was picked up
      UART1_Write_Line("You picked up a torpedo 3 pack bonus!");
    }

    
    //reset the bonus block position
    ResetBonusBlock();
    
    //Fill the screen with the blue sea color
    TFT_Fill_Screen(bgColor);
  }



  //Draw the fireball explosion sprite when the sub collides with a sea mine
  if(mineHit){
    //Your sub was destroyed

    //Center the fireball on the sub
    fireball.x = (sub.x + (PLAYER_WIDTH/2) ) - (fireball.width/2) ;
    fireball.y = (sub.y + (PLAYER_HEIGHT/2) ) - (fireball.height/2) ;

    //Keep the fireball from going off the top or left side of the screen
    if( fireball.x <=0)
    fireball.x=0;

    if( fireball.y <= STATUS_TEXT_CELL_HEIGHT)
    fireball.y = STATUS_TEXT_CELL_HEIGHT;
    
    //Show fireball image
    TFT_Image(fireball.x, fireball.y, fireball_bmp, 1);

    //Fill the screen with the blue sea color
    TFT_Fill_Screen(bgColor);

  }



  //Draw the fireball explosion sprite when the torpedo blows up a sea mine
  if(mineExplode){
    //A torpedo blew up a sea mine

    //Status debugging
    //UART1_Write_Line("torpedo.x:");
    //UART1_Write_Variable(torpedo.x);
    
    //Clear the torpedo sprite
    ClearTorpedo();
    
    //Center the explosion on the destroyed seamine
    explode.x = (mine[destroyed_mine_id].x + (mine[destroyed_mine_id].width/2) ) - (explode.width/2) ;
    explode.y = (mine[destroyed_mine_id].y + (mine[destroyed_mine_id].height/2) ) - (explode.height/2);

    //Keep the fireball from going off the top or left side of the screen
    if( explode.x <=0 ){
      explode.x=0;
    }

    if( explode.y <= STATUS_TEXT_CELL_HEIGHT){
      explode.y = STATUS_TEXT_CELL_HEIGHT;
    }

    //Show fireball image
    TFT_Image(explode.x, explode.y, explode_bmp, 1);
    Delay_ms(100);

    //Fill the screen with the blue sea color
    TFT_Fill_Screen(bgColor);


    //Reset mineExplode flag
    mineExplode = 0;

    //Reset torpedo launch flag
    fire_torpedo_flag = 0;

    //Reset the torpdedo after explosion
    torpedo.x = 0;
    torpedo.y = 0;
    torpedo.prev_x = 0;
    torpedo.prev_y = 0;

    //Reset the mine position after collision
    //Draw the new mine position staring on the right edge of the screen
    ResetSeaMine(destroyed_mine_id);
    mine[destroyed_mine_id].prev_x = mine[destroyed_mine_id].x;

    //Increase the score
    if(mine[destroyed_mine_id].type == 0){
      score += 50;
    }
    else if(mine[destroyed_mine_id].type == 1){
      score += 100;
    }
  }

  //Check if the current level is over
  CheckGameLevel();
  

  //Display the Score in the status bar
  RenderScore();

}


void CheckGameLevel(){
  //Set the game level
  if( (level == 1) && (score > 1000) ){
    level = 2;
    prev_level = level-1;

    //The mine scrolling speed
    mine_speed = 8;

    //The bonus frequency factor
    bonus_factor = 1;

    //The rate from 1 to 5 of a grey sea mine occuring
    grey_mine_rate = 5;

  }

  if( (level == 2) && (score > 2500) ){
    level = 3;
    prev_level = level-1;

    //The mine scrolling speed
    mine_speed = 8;

    //The bonus frequency factor
    bonus_factor = 1;

    //The rate from 1 to 5 of a grey sea mine occuring
    grey_mine_rate = 4;

    //give an extra sub life
    subLives++;
  }

  if( (level == 3) && (score > 5000) ){
    level = 4;
    prev_level = level-1;

    //The mine scrolling speed
    mine_speed = 8;

    //The bonus frequency factor
    bonus_factor = 2;

    //The rate from 1 to 5 of a grey sea mine occuring
    grey_mine_rate = 3;

    //give an extra sub life
    subLives++;
  }

  if( (level == 4) && (score > 8000) ){
    level = 5;
    prev_level = level-1;

    //The mine scrolling speed
    mine_speed = 9;

    //The bonus frequency factor
    bonus_factor = 3;

    //The rate from 1 to 5 of a grey sea mine occuring
    grey_mine_rate = 3;

    //give an extra sub life
    subLives++;
  }

  if( (level == 5) && (score > 10000) ){
    level = 6;
    prev_level = level-1;

    //The mine scrolling speed
    mine_speed = 10;

    //The bonus frequency factor
    bonus_factor = 3;
    
    //The rate from 1 to 5 of a grey sea mine occuring
    grey_mine_rate = 3;

    //give an extra sub life
    subLives++;
  }

  if( (level == 6) && (score > 12000) ){
    level = 7;
    prev_level = level-1;

    //The mine scrolling speed
    mine_speed = 10;

    //The bonus frequency factor
    bonus_factor = 3;
    
    //The rate from 1 to 5 of a grey sea mine occuring
    grey_mine_rate = 3;

    //give an extra sub life
    subLives++;
  }

  if( (level == 7) && (score > 15000) ){
    level = 8;
    prev_level = level-1;

    //The mine scrolling speed
    mine_speed = 10;

    //The bonus frequency factor
    bonus_factor = 4;

    //The rate from 1 to 5 of a grey sea mine occuring
    grey_mine_rate = 3;

    //give an extra sub life
    subLives++;
  }

  if( (level == 8) && (score > 15000) ){
    level = 9;
    prev_level = level-1;

    //The mine scrolling speed
    mine_speed = 10;

    //The bonus frequency factor
    bonus_factor = 3;

    //The rate from 1 to 5 of a grey sea mine occuring
    grey_mine_rate = 2;

    //give an extra sub life
    subLives++;
  }
  if( (level == 9) && (score > 20000) ){
    level = 10;
    prev_level = level-1;

    //The mine scrolling speed
    mine_speed = 10;

    //The bonus frequency factor
    bonus_factor = 4;

    //The rate from 1 to 5 of a grey sea mine occuring
    grey_mine_rate = 2;

    //give an extra sub life
    subLives++;
  }


  if (prev_level != level){
    //Switch to the next level
    ShowNextLevel();
  }



}


void RenderScore(){
  int tr_inc = 0;
  #define TORPEDO_STATUS_ICON_WIDTH 6

  //Display the Score in the status bar


  //setup the default font
  TFT_Set_Font(TFT_defaultFont, CL_WHITE, FO_HORIZONTAL);


  //Redraw the background behind the text if the values have changed
  if( (score != prev_score) ||
      (prev_torpedo_count != torpedo_count) ||
      (prev_subLives != subLives) ||
      ( prev_muteSound != muteSound) || 
      (toggled_main_menu) ){

    //Debugging test region black fill color
    // TFT_Set_Brush(1, CL_BLACK, 0, TOP_TO_BOTTOM, CL_BLACK, CL_BLACK);

    //Set the line drawing color
    TFT_Set_Pen(bgColor, 1);

    //Set the shape fill color
    TFT_Set_Brush(1, bgColor, 0, TOP_TO_BOTTOM, CL_BLACK, CL_BLACK);

    //Blank the score background
    TFT_Rectangle( 0, 0, 319, 25);
  }
  
  //Draw the sub lives and the remaining torpedos icons
  
  
  //Torpedos remaining icon
  //TFT_Image(260, 4, torpedo_bmp, 1);
  for(tr_inc=0;tr_inc<torpedo_count;tr_inc++){
    TFT_Image(230+((TORPEDO_STATUS_ICON_WIDTH+2)*tr_inc), 2, torpedo_status_bmp, 1);
  }

  //Lives remaining icon
  TFT_Image(5, 2, lives_bmp, 1);

  
  //Torpedos remaining icon
  //TFT_Image(5, 4, torpedo_bmp, 1);

  //Lives remaining icon
  //TFT_Image(270, 2, lives_bmp, 1);
  

  if(muteSound){
    //Sound off (muted) icon
    TFT_Image(80, 2, soundMute_bmp, 1);
  }
  else if(!muteSound){
  
    if (sound_level > 75) {
      //Sound on icon
      TFT_Image(80, 2, sound_bmp, 1);
    }
    else if (sound_level > 40){
      //Sound on icon
      TFT_Image(80, 2, sound_med_bmp, 1);
    }
    else{
      //Sound on icon
      TFT_Image(80, 2, sound_low_bmp, 1);
    }

  }
  
  
  
  //Convert the level number from an int to string
  IntToStr(level, level_text);

  //Convert the sub lives from an int to string
  IntToStr(subLives, lives_text);

  //Convert the torpedoes from an int to string
  IntToStr(torpedo_count, torpedoes_text);

  //Convert the score from an int to string
  IntToStr(score, score_text);


  //Write the lives remaining text onscreen
  TFT_Write_Text(lives_text, (5 + 20), 2);

  //Write the torpedoes remaining text onscreen
  //TFT_Write_Text(torpedoes_text, (260 + 35), 2);

  //Set up the font and font color
  TFT_Set_Font(TFT_defaultFont, CL_WHITE, FO_HORIZONTAL);

  //Create the score string
  strcpy(score_display_text, "Score: ");
  strcat(score_display_text, score_text);
  
  //Write the score onscreen
  TFT_Write_Text(score_display_text, 120, 2);
}

//Erase the exploded torpedo
void ClearTorpedo(){
  //Set up the clear rect for the exploded torpedo
  clear_torpedo.left = torpedo.x;
  clear_torpedo.top =  torpedo.y;
  clear_torpedo.right =  torpedo.x+torpedo.width;
  clear_torpedo.bottom =  torpedo.y+torpedo.height;

  //Erase the torpedo from the screen
  TFT_Rectangle( clear_torpedo.left, clear_torpedo.top, clear_torpedo.right, clear_torpedo.bottom);
}




void ResetGame(){

  //Fill the screen with the blue sea color
  TFT_Fill_Screen(bgColor);

  //setup the default font
  TFT_Set_Font(TFT_defaultFont, CL_WHITE, FO_HORIZONTAL);

  TFT_Set_Pen(bgColor, 1);

  //Set the fill brush to the sea color
  TFT_Set_Brush(1, bgColor, 0, TOP_TO_BOTTOM, bgColor, bgColor);


  //Reset the current level number
  level = 1;
  prev_level = 1;

  //Reset the score
  score = 0;

  //High levels test
  //score = 10025;
  //level = 7;
  //prev_level = 6;


  //Reset the starting bonus frequency factor
  bonus_factor = 1;

  //Reset the horizontal mine speed
  mine_speed = 6;

  //How many torpedos the sub starts with
  torpedo_count = NUMBER_OF_TORPEDOES;

  //Reset the number of submarine lives
  subLives = NUMBER_OF_SUBMARINES;

  //Reset the number of bonuses displayed counter
  bonus_counter = 0;

  //The rate from 1 to 5 of a grey seamine occuring
  grey_mine_rate = 5;

  //Reset the sprites
  InitSprites();
}

void InitSprites(){
  int mine_inc = 0;
  
  
  //Reset the number of torpedos the sub has
  torpedo_count = NUMBER_OF_TORPEDOES;
  
  //Reset torpedo fired flag
  fire_torpedo_flag = 0;
  
  
  //Sub sprite
  sub.x = 28;
  sub.y = 128;
  sub.prev_x = sub.x;
  sub.prev_y = sub.y;
  
  
  //Sub explosion Fireball sprite
  fireball.x = 0;
  fireball.y = 0;
  fireball.prev_x = 0;
  fireball.prev_y = 0;
  fireball.width = 130;
  fireball.height = 134;
  
  
  //Sea mine explosion
  explode.x = 0;
  explode.y = 0;
  explode.prev_x = 0;
  explode.prev_y = 0;
  explode.width = 70;
  explode.height = 60;
  
  //torpedo sprite
  torpedo.x = 0;
  torpedo.y = 0;
  torpedo.prev_x = 0;
  torpedo.prev_y = 0;
  torpedo.visible = 1;
  torpedo.width = 35;
  torpedo.height = 14;
  
  //Mine sprites starting position
  for(mine_inc = 0; mine_inc <= (NUMBER_OF_SEA_MINES-1); mine_inc++){
    mine[mine_inc].x = (mine_inc * 90) + 200;
    mine[mine_inc].y = RandomHeightY();

    mine[mine_inc].prev_x = mine[mine_inc].x ;
    mine[mine_inc].prev_y = mine[mine_inc].y ;
    mine[mine_inc].width = 45;
    mine[mine_inc].height = 45;

    //Picks the seamine type - either red or grey
    mine[mine_inc].type = RandomSeaMineType();
    
    //Sets the seamine to be a standard red version
    //mine[mine_inc].type = 0;
    
    //Reset the mine hits counter
    mine[mine_inc].hits = 0;
  }
  
  
  //Torpedo bonus block sprite
  //Start the block on the 3rd screen
  bonus_block.x = SCREEN_WIDTH*BONUS_SCREEN_SPACING;
  bonus_block.y = RandomHeightY();  //generate random block Y position
  bonus_block.prev_x = 0;
  bonus_block.prev_y = 0;
  bonus_block.visible = 1;
  bonus_block.width = 45;
  bonus_block.height = 45;
  
  //set the starting bonus to be a torpedo pack
  bonus_type = 1;
  
  //Set the line drawing color
  TFT_Set_Pen(bgColor, 1);
  
  //Set the shape fill color
  TFT_Set_Brush(1, bgColor, 0, TOP_TO_BOTTOM, CL_BLACK, CL_BLACK);
  
  //Fill the screen with the blue sea color
  TFT_Fill_Screen(bgColor);
  
}

//Save the previous sprite positions
void SavePreviousVal(){
  int mine_inc = 0;
  
  //Save the previous score
  prev_score = score;
  
  //Previous sub position
  sub.prev_x = sub.x;
  sub.prev_y = sub.y;
  
  //Previous sea mine position
  for(mine_inc = 0; mine_inc <= (NUMBER_OF_SEA_MINES-1); mine_inc++){
    mine[mine_inc].prev_x = mine[mine_inc].x;
    mine[mine_inc].prev_y = mine[mine_inc].y;
  }
  
  //Previous torpedo position
  torpedo.prev_x = torpedo.x;
  torpedo.prev_y = torpedo.y;
  
  //Previous bonus block position
  bonus_block.prev_x = bonus_block.x;
  bonus_block.prev_y = bonus_block.y;
  
  //Previous values for refreshing the status screen
  prev_torpedo_count = torpedo_count;
  prev_subLives = subLives;
  
  //Reset the destroyed sea mine id number
  destroyed_mine_id = -1;
  
  //Reset the bonus id
  bonus_id = -1;
  
  //Save previous level
  prev_level = level;
  
  //previous sound on / off setting
  prev_muteSound = muteSound;
  
}


//Check for a sprite to mine collision
char IsCollision (unsigned int Shape_X, unsigned int Shape_Y,  unsigned int Shape_Width, unsigned int Shape_Height,
unsigned int Bomb_Left, unsigned int Bomb_Top, unsigned int Bomb_Width, unsigned int Bomb_Height) {
  
  //Check for sea mine sidewall collisions
  //The right side of Shape is greater than left side of Bomb     and        left side of Shape is smaller than right side of Bomb
  if( ((Shape_X + Shape_Width) >= Bomb_Left )               &&              ((Shape_X) <= (Bomb_Left + Bomb_Width-1)) &&
      
      
      //Check for sea mine top and bottom collisions 
      //The bottom side of Shape is greater than top of Bomb         and            top of Shape is smaller then bottom of Bomb
      ((Shape_Y + Shape_Height) >= Bomb_Top )                   &&               ((Shape_Y) <= (Bomb_Top + Bomb_Height-1))  ) {
    
    
    //Debug printing
    //UART1_Write_Line("Collision detected");
    
    //A collision has been detected
    return 1;
  }
  else
  {
    //Default return value
    //No collisions have been detected
    return 0;
  }
  
}


//Load the next song
void GetNextSong(){
  UART1_Write_Line("Switching to the next song.");

  Load_MP3_File("Pavese.mp3");

  //Get the MP3 header data loaded before the game continues
  if(current_pos < 10){
    PreRollSong();
  }

}

//Preroll first few bytes of the song at the startup to load the MP3 header data
void PreRollSong(){
  int roll = 0;
  int roll_max = 100;   //120

  //Start playing the sound
  for(roll = 0; roll<=roll_max;roll++){
    Play_MP3_Chunk();
  }
}


void ToggleMute(){
  //Turn on sound
  if(muteSound){
    muteSound = 0;
    UART1_Write_Line("Sound On");
    PreRollSong();
  }
  else if(!muteSound){
    //Mute the sound
    muteSound = 1;
    UART1_Write_Line("Muting Sound");
  }

}




//Animate the Sea Mine sprites
void AnimateSeaMine(int mineNum){
  unsigned long the_frame = 0;

  //Calculate the animated sea mine frame number
  the_frame = (frame_counter + mineNum) % 6;


  //If the seamine.type equals zero it is a red mine
  if(mine[mineNum].type == 0) {

    //Select the red sea mine sprite
    switch (the_frame) {
    case 0 :
      TFT_Image(mine[mineNum].x, mine[mineNum].y, mine6_bmp, 1);
      break;

    case 1 :
      TFT_Image(mine[mineNum].x, mine[mineNum].y, mine5_bmp, 1);
      break;

    case 2 :
      TFT_Image(mine[mineNum].x, mine[mineNum].y, mine4_bmp, 1);
      break;

    case 3 :
      TFT_Image(mine[mineNum].x, mine[mineNum].y, mine3_bmp, 1);
      break;

    case 4 :
      TFT_Image(mine[mineNum].x, mine[mineNum].y, mine2_bmp, 1);
      break;

    case 5 :
      TFT_Image(mine[mineNum].x, mine[mineNum].y, mine1_bmp, 1);
      break;

    default:
      TFT_Image(mine[mineNum].x, mine[mineNum].y, mine1_bmp, 1);
      break;
    }
    
  }
  else{
    
    //Select the grey sea mine sprite
    switch (the_frame) {
    case 0 :
      TFT_Image(mine[mineNum].x, mine[mineNum].y, dark_mine6_bmp, 1);
      break;

    case 1 :
      TFT_Image(mine[mineNum].x, mine[mineNum].y, dark_mine5_bmp, 1);
      break;

    case 2 :
      TFT_Image(mine[mineNum].x, mine[mineNum].y, dark_mine4_bmp, 1);
      break;

    case 3 :
      TFT_Image(mine[mineNum].x, mine[mineNum].y, dark_mine3_bmp, 1);
      break;

    case 4 :
      TFT_Image(mine[mineNum].x, mine[mineNum].y, dark_mine2_bmp, 1);
      break;

    case 5 :
      TFT_Image(mine[mineNum].x, mine[mineNum].y, dark_mine1_bmp, 1);
      break;

    default:
      TFT_Image(mine[mineNum].x, mine[mineNum].y, dark_mine1_bmp, 1);
      break;
    }
    
  }



}


//define the startup sound volume
void Startup_Volume( char vol){
sound_level = vol;
MP3_Set_Volume(100 - sound_level, 100 - sound_level);
UpdateVolumeBar(sound_level, old_sound_level);
UART1_Write_Label_Var("Sound Volume:", sound_level );
}



//UART1 write label and variable (carriage return + line feed)
void UART1_Write_Label_Var(char *uart_text, int var ) {
  char var_txt[12];

  UART1_Write_Text(uart_text);
  IntToStr(var, var_txt);
  UART1_Write_Text(var_txt);
  UART1_Write(13);
  UART1_Write(10);
}


//UART1 write label and long variable (carriage return + line feed)
void UART1_Write_Label_Long_Var(char *uart_text, long var){
char var_txt[20];

UART1_Write_Text(uart_text);
LongToStr(var, var_txt);
UART1_Write_Text(var_txt);
UART1_Write(13);
UART1_Write(10);
}

//UART1 write label and float variable (carriage return + line feed)
void UART1_Write_Label_Float_Var(char *uart_text, float var){
char var_txt[20];

UART1_Write_Text(uart_text);
FloatToStr(var, var_txt);
UART1_Write_Text(var_txt);
UART1_Write(13);
UART1_Write(10);
}